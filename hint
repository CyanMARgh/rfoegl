#include "glad.h"
#include <GLFW/glfw3.h>
#include <iostream>
#include <vector>
#include <thread>
#include <fstream>
#include <streambuf>
#include <cmath>
#include <glm/vec4.hpp>
#include <glm/vec2.hpp>
#include <numeric>

typedef uint32_t u32;
typedef int32_t s32; 

void ProcessInput(GLFWwindow* window) {
	if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
		glfwSetWindowShouldClose(window, true);
	}
}
void FrameBufferSizeCallback(GLFWwindow* window, int width, int height) {
	glViewport(0, 0, width, height);
}

std::string readfile(const std::string& path) {
	std::ifstream fin(path);
	std::string str((std::istreambuf_iterator<char>(fin)),
                 std::istreambuf_iterator<char>());
	return str;
}

struct GlContext {
	GlContext() {
		glfwInit();
		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
		glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	}
	~GlContext() {
		glfwTerminate();
	}
};
struct Window {
	GLFWwindow* window;
	Window() {
		window = glfwCreateWindow(800, 600, "~~~", NULL, NULL);
		glfwMakeContextCurrent(window);
		if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
			std::cout << "Failed to initialize GLAD" << std::endl;
			exit(-1);
		}
		glViewport(0, 0, 800, 600);
	}
	void Clear(float r, float g, float b, float a) {
		glClearColor(r, g, b, a);
		glClear(GL_COLOR_BUFFER_BIT);
	}
};
struct Shader {
	typedef decltype(GL_VERTEX_SHADER) type_t;

	s32 id;

	Shader(type_t type, const std::string& source) {
		auto csource = source.c_str();
		id = glCreateShader(type);
		glShaderSource(id, 1, &csource, NULL);
		glCompileShader(id);

		int success;
		char infoLog[512];
		glGetShaderiv(id, GL_COMPILE_STATUS, &success);
		if (!success) {
			glGetShaderInfoLog(id, 512, NULL, infoLog);
			std::cout << "SHADER COMPILATION FAILED:\n" << infoLog << std::endl;
		}	
	}
	~Shader() {
		glDeleteShader(id);
	}
};
struct ShaderProgram {
	s32 id;
	ShaderProgram(const Shader& vs, const Shader& fs) {
		id = glCreateProgram();
		glAttachShader(id, vs.id);
		glAttachShader(id, fs.id);
		glLinkProgram(id);
	}
	void SetUniform(const std::string& name, glm::vec4 val) {
		glUniform4f(glGetUniformLocation(id, name.c_str()),
			val.x, val.y, val.z, val.w);
	}
	void SetUniform(const std::string& name, glm::vec2 val) {
		glUniform2f(glGetUniformLocation(id, name.c_str()),
			val.x, val.y);
	}
	void SetUniform(const std::string& name, float val) {
		glUniform1f(glGetUniformLocation(id, name.c_str()),
			val);
	}
};
struct Mesh {
	std::vector<float> verts;
	std::vector<u32> ids;

	u32 VBO, VAO, EBO;
	Mesh(std::vector<float>&& _verts, std::vector<u32>&& _ids, const std::vector<u32>& attrSizes) {
		verts = std::move(_verts);
		ids = std::move(_ids);

		glGenBuffers(1, &VBO);
		glBindBuffer(GL_ARRAY_BUFFER, VBO);
		glBufferData(GL_ARRAY_BUFFER, verts.size() * sizeof(float), &(verts[0]), GL_STATIC_DRAW);

		glGenBuffers(1, &EBO);
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, ids.size() * sizeof(u32), &(ids[0]), GL_STATIC_DRAW);

		glGenVertexArrays(1, &VAO);
		glBindVertexArray(VAO);

		u32 total = std::accumulate(attrSizes.begin(), attrSizes.end(), 0u);
		for(u32 i = 0, s, S = 0, n = attrSizes.size(); i < n; i++, S += s) {
			s = attrSizes[i];
			glVertexAttribPointer(i, s, GL_FLOAT, GL_FALSE, total * sizeof(float), (void*)(S*sizeof(float)));
			glEnableVertexAttribArray(i);

		}
		glBindVertexArray(0);
	}
	void refresh() {
		glBufferData(GL_ARRAY_BUFFER, verts.size() * sizeof(float), &(verts[0]), GL_STATIC_DRAW);
	}
};

float randf() {
	return ((float)rand() * 2.f)/RAND_MAX - 1.f;
}

void foo() {

}

int main() {
	foo();
	GlContext glc;
	Window w;

	Mesh mesh({
		1.0f,  1.0f, 0.0f, 1.f, 1.f,
		1.0f, -1.0f, 0.0f, 1.f, 0.f,
		-1.0f, -1.0f, 0.0f, 0.f, 0.f,
		-1.0f,  1.0f, 0.0f,  0.f, 1.f
	},{
		0, 1, 3,
		1, 2, 3
	}, {3, 2});
	ShaderProgram shaderProgram(
		Shader(GL_VERTEX_SHADER, readfile("vertex.vert")),
		Shader(GL_FRAGMENT_SHADER, readfile("fragment.frag"))
	);

	while(!glfwWindowShouldClose(w.window)) {
		ProcessInput(w.window);
		w.Clear(.2f, .3f, .3f, 1.f);

		shaderProgram.SetUniform("utime", glfwGetTime());
		shaderProgram.SetUniform("uresolution", glm::vec2(800.f, 600.f));

		glUseProgram(shaderProgram.id);
		
		glBindVertexArray(mesh.VAO);
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh.EBO);
		glDrawElements(GL_TRIANGLES, mesh.ids.size()*3, GL_UNSIGNED_INT, 0);

		glfwSwapBuffers(w.window);
		glfwPollEvents();
	}
    return 0;
}
